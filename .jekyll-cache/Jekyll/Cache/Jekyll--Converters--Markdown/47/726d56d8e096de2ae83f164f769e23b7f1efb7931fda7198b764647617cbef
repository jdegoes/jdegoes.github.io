I"™<p>I‚Äôve taught functional programming for years now, each time experimenting with different ways of teaching core concepts. Over time, I‚Äôve collected and converged on simple (but reasonably precise) pedagogical definitions for a range of functional concepts.</p>

<p>In this post, I‚Äôll share those definitions with you, in my first ever, <em>Glossary of Functional Programming</em>. Enjoy!</p>

<h2 id="glossary">Glossary</h2>

<p><strong>Abstraction</strong>. An <em>abstraction</em> is a precise description of the ways in which different data types share common structure. Abstraction allows different data types to participate in <em>generic programming</em>. In functional programming, abstractions are defined by <em>algebraic structure</em>, and are usually encoded in a programming language using <em>type classes</em>. Common examples of abstractions include monoids, functors, and monads.</p>

<p><strong>Ad Hoc Polymorphism</strong>. <em>Ad hoc polymorphism</em> is any language feature that allows overloading functions and operators (providing multiple implementations for the same symbol) in such a fashion that the compiler or runtime can automatically select which implementation to call based on the types involved in the function application. Examples of ad hoc polymorphism include method overloading and <em>type classes</em>.</p>

<p><strong>Algebra</strong>. An <em>algebra</em> is a set of <em>elements</em> together with a set of <em>operations</em> on the elements. The operations of an algebra are defined by <em>algebraic laws</em>, which give the operations meaning by relating them to each other. For example, addition on integers forms a very simple algebra, where the elements are integers, and the sole operation is addition, which satisfies assocative and commutative laws.</p>

<p><strong>Algebraic Data Type (ADT)</strong>. An <em>algebraic data type</em> is any data type composed from <em>product types</em> (records) and <em>sum types</em> (enumerations). In functional programming, algebraic data types are used for <em>data modeling</em>.</p>

<p><strong>Algebraic Law</strong>. An <em>algebraic law</em> is a <em>universally quantified</em> statement that asserts a relationship between the <em>operations</em> of an <em>algebra</em>. For example, an algebraic law for addition could assert that <code class="highlighter-rouge">(a + b) + c</code> is equal to <code class="highlighter-rouge">a + (b + c)</code> (<em>associativity</em>). In mainstream programming languages, algebraic laws are usually tested using <em>property-based testing</em>.</p>

<p><strong>Algebraic Structure</strong>. <em>Algebraic structure</em> is any <em>structure</em> that is defined using an <em>algebra</em>.</p>

<p><strong>Applicative</strong>. An <code class="highlighter-rouge">Applicative</code> Functor is an <code class="highlighter-rouge">Apply</code> Functor that allows taking a value and converting it into a <em>functional effect</em> that succeeds with the specified value. Under the view of functors as DSLs, <code class="highlighter-rouge">Applicative</code> adds a ‚Äúpure return‚Äù statement to the DSL.</p>

<p><strong>Apply</strong>. An <code class="highlighter-rouge">Apply</code> Functor is a Functor that allows zipping two <em>functional effects</em> together, to get a tuple of their successes. Under the view of functors as DSLs, <code class="highlighter-rouge">Apply</code> adds a way to combine two programs together into one program, and preserve both successes.</p>

<p><strong>Associativity</strong>. An <em>associative</em> operator is a binary operator that, when applied to three values, always results in the same value, regardless of the order in which pairwise values are combined. For example, addition on numbers is associative, because for all numbers <code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">b</code>, and <code class="highlighter-rouge">c</code>, <code class="highlighter-rouge">(a + b) + c</code> is equal to <code class="highlighter-rouge">a + (b + c)</code>.</p>

<p><strong>Category Theory</strong>. <em>Category theory</em> is a branch of mathematics that defines mathematical structure using directed labeled graphs (<em>categories</em>). An alternative to algebraically-defined structure, category theory is a powerful and precise pattern language for mathematics, computer science, and functional programming. Knowledge of category theory is helpful but not necessary for mastery of applied functional programming.</p>

<p><strong>Commutativity</strong>. A <em>commutative</em> operator is a binary operator that produces the same result no matter the order of the operands. For example, addition is commutative because <code class="highlighter-rouge">a + b</code> is equal to <code class="highlighter-rouge">b + a</code>, for all numbers <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code>.</p>

<p><strong>Composable</strong>. An operator is <em>composable</em> if it can be applied to its own return value. For example, the addition operator is composable with respect to integers, because it returns another integer, which can then be added to other integers. Similarly, the boolean negation operator is composable, because it is possible to negate a boolean value that has itself been negated. Composability allows a small number of operators (which can be reasoned about simply) to have immense expressive power.</p>

<p><strong>Contravariant Functor</strong>. A <code class="highlighter-rouge">Contravariant</code> Functor is a type class that allows transforming the input type to some <em>functional effect</em> using a function. Contravariant functors are often formed by polymorphic types that accept input (such as functions, or stages in a pipeline).</p>

<p><strong>Data Modeling</strong>. <em>Data modeling</em> is the act of constructing a data model of domain objects (such as people, products, schedules, etc.). A goal of data modeling in statically-typed functional programming is to construct a data model so precise, it is impossible to construct bad data, a process sometimes called, <em>making illegal states unrepresentable</em>.</p>

<p><strong>Declarative Programming</strong>. <em>Declarative programming</em> is a style of programming in which solutions are constructed by specifying goals, rather than specifying the sequential steps necessary to achieve these goals (<em>what</em> instead of <em>how</em>). Declarative programming is the opposite of imperative programming. Some languages, such as SQL and Datalog, are inherently declarative; but declarative programming can be practiced in any programming language, typically by defining declarative DSLs atop imperative implementations.</p>

<p><strong>Dependency Injection</strong>. <em>Dependency injection</em> refers to a framework, library, language feature, or architectural pattern that facilitates threading dependencies throughout an application, and wiring up those dependencies for different scenarios. Dependency injection is one of the primary architectural needs of large-scale, complex applications.</p>

<p><strong>Dependent Typing</strong>. <em>Dependent typing</em> is a method of defining types that permits types to depend on values. For example, in dependently typed programming languages, one can define the type of vectors whose length is equal to some value. Examples of dependently typed programming languages include Idris, Coq, and Agda. Dependently typed programming languages allow proving more properties about programs at compile-time, albeit at increased development cost.</p>

<p><strong>Deterministic</strong>. A <em>deterministic</em> procedure returns the same output for the same input.</p>

<p><strong>Domain-Specific Language (DSL)</strong>. A <em>domain-specific language</em> (DSL) is a ‚Äúmini-language‚Äù that is designed to solve a certain subproblem in an application. In functional programming, DSLs are generally <em>embedded</em>, which means users of these DSL use data types and operators, defined in the host language, to construct programs in the DSL.</p>

<p><strong>Effect Rotation</strong>. <em>Effect rotation</em> refers to the construction of highly polymorphic data types (typically <em>indexed monads</em>) that simultaneously support multiple <em>functional effects</em>. Each effect supported by the data type is represented with a different type parameter, and each effect may be introduced or eliminated using certain operations. Effect rotation provides much of the benefit of monad transformers, but with substantially improved performance, and in some languages like Scala, significantly better type inference.</p>

<p><strong>Existential Quantification</strong>. <em>Existential quantification</em> asserts that a statement holds for some choice of a given variable. For example, the value <code class="highlighter-rouge">list: List[_]</code> is existentially quantified over the <code class="highlighter-rouge">List</code> type parameter, asserting that there exists some (unknown) type that describes the type of elements in the list, without specifying what this type is.</p>

<p><strong>Existential Type</strong>. An <em>existential type</em> is a specific, definite type, which is unknown to code interacting with the type. In programming languages, existential types are used to ‚Äúforget‚Äù information that need not be carried around in type parameters. In Scala, abstract type members are always existential types.</p>

<p><strong>Expression</strong>. An <em>expression</em> is a value constructed from the application of functions or operators to other values. The parameters to the functions or operators are called the <em>terms</em> of the expression. For example, <code class="highlighter-rouge">a + b</code> is an expression, which computes the result of adding the term <code class="highlighter-rouge">a</code> to the term <code class="highlighter-rouge">b</code>.</p>

<p><strong>F-Algebra</strong>. An F-algebra is a generalization of algebraic structure that comes from category theory, which makes it possible to represent algebraic laws without universal quantification, using only morphisms. In functional programming, F-algebras appear more directly as interpreters for both tagless-final and free monadic programs (<em>natural transformations</em>), and as algebras and coalgebras in recursion schemes.</p>

<p><strong>First-Class</strong>. <em>First-class</em> constructs are those which can be created, manipulated, and abstracted over using the most powerful machinery a language exposes for these tasks. For most programming language, <em>first-class</em> means the construct is a <em>value</em>. First-class constructs give programmers much more power than second-class constructs. Some constructs which are not first-class can nonetheless be <em>reified</em> to obtain some of the benefits of being first-class.</p>

<p><strong>Flow analysis</strong>. Type-directed <em>flow analysis</em> is a process whereby the flow of information in the declaration of a data type or a function is analyzed using type information alone. Performing flow analysis can yield useful information about the implementation of polymorphic declarations. For example, for a function <code class="highlighter-rouge">def foo[A](a: A): A</code> (<code class="highlighter-rouge">foo :: a -&gt; a</code>), one can tell using flow analysis that the output of the function must have come from its single input parameter, because there is no other way for the function to return a value of the polymorphic type.</p>

<p><strong>Free Structure</strong>. A <em>free structure</em> is a data structure that <em>reifies</em> operations of some algebra into a tree-like data structure. Later, the data structure can be traversed, and the operations applied to concrete values‚Äîa process called <em>interpretation</em> of the free structure. An example free structure is <code class="highlighter-rouge">List</code> (<code class="highlighter-rouge">[]</code>), which is a free monoid for any type <code class="highlighter-rouge">A</code>; that is, for any type <code class="highlighter-rouge">A</code>, <code class="highlighter-rouge">List[A]</code> (<code class="highlighter-rouge">[a]</code>) provides both a neutral value (the empty list) and an append operation (list concatenation). Another example is <code class="highlighter-rouge">Free</code>, which provides a free monad for any type constructor <code class="highlighter-rouge">F[_]</code> (<code class="highlighter-rouge">f : * -&gt; *</code>).</p>

<p><strong>Function</strong>. A mathematical <em>function</em> <code class="highlighter-rouge">f : A =&gt; B</code> (<code class="highlighter-rouge">f :: a -&gt; b</code>) associates every value in a set <code class="highlighter-rouge">A</code> (called the <em>domain</em>) with a single value in a set <code class="highlighter-rouge">B</code> (called the <em>codomain</em>). For a given function, this mapping is static (it does not change). In programming languages, the domains and codomains of value-level functions are types, and all such functions are <em>total</em> (they map every input to some output), <em>deterministic</em> (they map the same input to the same output), and <em>pure</em> (they only map inputs to outputs).</p>

<p><strong>Functional Effect</strong>. A <em>functional effect</em> is an immutable data type that describes (or <em>models</em>) the computation of one or more values, where the computation may require an additional feature like optionality, logging, access to context (like configuration), errors, state, or input/output. Using effect-specific operations, functional effects can be transformed and composed to model solutions to complex problems out of solutions to smaller problems. The ways of constructing a functional effect, together with the operations on effects of that type, form a DSL, whose capabilities are dictated by the constructors and operations. Frequently, functional effects are <em>run</em> or <em>interpreted</em> into plain values or into other functional effects. Common functional effects include <code class="highlighter-rouge">Option</code> (<code class="highlighter-rouge">Maybe</code>), which models missing values; <code class="highlighter-rouge">Either</code>, which models failure; and <code class="highlighter-rouge">ZIO</code> (<code class="highlighter-rouge">IO</code>), which models side-effects, including asynchronous side-effects.</p>

<p><strong>Functional Programming</strong>. <em>Functional programming</em> is a style of programming in which solutions are constructed by defining and applying (mathematical) <em>functions</em>. Many programs are not ‚Äúpurely‚Äù functional, but contain parts that are written in a functional style, as well as parts that are written in a procedural style. Functional programming can be practiced in statically-typed as well as untyped programming languages.</p>

<p><strong>Functional-Imperative</strong>. <em>Functional-imperative</em> is a hybrid style of programming that uses higher-order functions to embed an imperative model of computation inside functional code. Functional-imperative style relies on <em>monads</em> or an equally powerful abstraction to represent the stateful sequentiality of imperative computations.</p>

<p><strong>Functor</strong>. A <code class="highlighter-rouge">Functor</code> is a type class that allows <em>mapping</em> the success value of some <em>functional effect</em> using a function. Every functor can be regarded as a type of DSL, where the terms in the functor sum type correspond to different instructions in the DSL. Under this view of functors as DSLs, <code class="highlighter-rouge">Functor</code> provides a way to change the success value of a DSL ‚Äúprogram‚Äù into some other success value, by applying a specified function.</p>

<p><strong>Generalized Algebraic Data Type (GADTs)</strong>. <em>Generalized algebraic data types</em> are polymorphic ADTs whose component types may introduce existential types or impose type equality constraints on specific type parameters. GADTs enable easier modeling and use of type-safe DSLs.</p>

<p><strong>Generic Programming</strong>. <em>Generic programming</em> is a style of programming that uses <em>polymorphism</em> to ‚Äúforget‚Äù irrelevant details about data types, which allows code to be used across many different data types that share common structure. Generic programming can be thought of as defining a ‚Äútemplate‚Äù that is then specialized to concrete types.</p>

<p><strong>Global Reasoning</strong>. <em>Global reasoning</em> is a property of some code wherein the correctness of the code cannot be inferred without considering prior application state or all possible inputs.</p>

<p><strong>Higher-Kinded Types</strong>. <em>Higher-kinded types</em>, more precisely called <em>higher-kinded generics</em>, is a language feature in which type parameters may have a kind higher than <code class="highlighter-rouge">*</code>. The two most mainstream languages with higher-kinded types are <em>Scala</em> and <em>Haskell</em>.</p>

<p><strong>Higher-Order</strong>. <em>Higher-order</em> refers to higher-order functions, which are functions that accept functions as input, or return functions as output. For example, <code class="highlighter-rouge">map</code> on a list is a higher-order function, because it accepts a function as one of its parameters; similarly, the <code class="highlighter-rouge">Monad</code> type class is a higher-order type class, because the kind of its type parameter is <code class="highlighter-rouge">(* =&gt; *) =&gt; *</code>, which is a higher-order type-level function.</p>

<p><strong>Homomorphism</strong>. <em>Homomorphisms</em> are a special type of function <code class="highlighter-rouge">f : A =&gt; B</code> that preserve a given <em>algebraic structure</em>. For example, the square function (which returns its input multiplied by itself) is a semigroup homomorphism, because it preserves, for example, the multiplicative semigroup.</p>

<p><strong>Imperative Programming</strong>. <em>Imperative programming</em> is a style of programming in which solutions are constructed from step-by-step instructions, where later instructions can depend on the result of previous instructions. In procedural programming, imperative programming is typically done with side-effecting statements, whereas in functional programming, imperative programming is typically done with <em>monads</em>.</p>

<p><strong>Indexed Monad</strong>. An <em>indexed monad</em> is a generalization of <code class="highlighter-rouge">Monad</code> for highly polymorphic data types having multiple type parameters, which form ordinary <code class="highlighter-rouge">Monad</code> instances for any possible choice of the extra type parameters. Indexed monads allow increased type precision, and allow operations that cannot be expressed with non-indexed monads. Examples of indexed monads included indexed state and <code class="highlighter-rouge">RIO</code> (in Haskell), and <code class="highlighter-rouge">ZIO</code> (in Scala).</p>

<p><strong>Indirection</strong>. <em>Indirection</em> is any programming language feature (interfaces, type classes, records of functions, module definitions) that allows multiple implementations of some required functionality to be defined and provided to code that requires these capabilities. Indirection facilitates testability, code reuse, and modularity, both in functional programming, and in other paradigms.</p>

<p><strong>Isomorphism</strong>. An <em>isomorphism</em> is an equivalence between two data types that have the same information. An isomorphism is defined by two functions: one to translate from the first data type to the second; and one to translate from the second data type to the first. These functions must satisfy ‚Äúroundtrip‚Äù laws in order for them to form an isomorphism, which demonstrate the two representations contain the same information. In functional programming, many things are considered equal <em>up to isomorphism</em>. For example, <code class="highlighter-rouge">(A, Unit)</code> and <code class="highlighter-rouge">A</code> are <em>equal up to isomorphism</em>, meaning these two different types have the same information.</p>

<p><strong>Kind</strong>. A <em>kind</em> describes the structure of a type or type constructor. Monomorphic types like <code class="highlighter-rouge">Float</code> and <code class="highlighter-rouge">Boolean</code>, which take no type parameters, belong to the set of all types, which is denoted <code class="highlighter-rouge">*</code> (‚Äústar‚Äù). Type constructors like <code class="highlighter-rouge">List</code> (<code class="highlighter-rouge">[]</code>) and <code class="highlighter-rouge">Option</code> (<code class="highlighter-rouge">Maybe</code>) belong to the set of all type constructors that take one type and return one type, which is denoted <code class="highlighter-rouge">* =&gt; *</code> (‚Äústar to star‚Äù). All kinds higher than <code class="highlighter-rouge">*</code> are type-level functions, which accept types (or type constructors) and return types. For example, if you give the <code class="highlighter-rouge">List</code> type constructor the type <code class="highlighter-rouge">Boolean</code>, then you get back the type representing lists of boolean values. The terminology and notation of kinds allow us to talk about the ways in which different types and type constructors are similar or distinct.</p>

<p><strong>Lambda</strong>. A <em>lambda</em> is an anonymous function, which is a function value that has no name. Because lambdas are values, lambdas may be passed to functions, and returned from functions. All languages that support functional programming provide a way to encode lambdas.</p>

<p><strong>Lambda Calculus</strong>. The <em>lambda calculus</em> is a way of expressing arbitrary computation using only <em>lambdas</em>. The lambda calculus is an alternative to Turing machines and other calculi of computation, and gives meaning to the term <em>functional programming</em>. There are many different formulations of the lambda calculus, not just one.</p>

<p><strong>Lenses</strong>. <em>Lenses</em> are <em>optics</em> that allow getting and setting terms in <em>product types</em>. For example, a lens could allow getting and setting the <em>name</em> field inside objects of type <code class="highlighter-rouge">Person</code>. In the functional context, <em>setting</em> a term in a product means creating a new modified product, given the new value for the term, and the old product value.</p>

<p><strong>Liskov Substitution Principle</strong>. The <em>Liskov substitution principle</em> says that if a function accepts an input of type <code class="highlighter-rouge">A</code>, then it should be valid to pass the function any subtype of <code class="highlighter-rouge">A</code>, without altering the correctness of the function. Similarly, for a function returning an output of type <code class="highlighter-rouge">B</code>, it should be valid for the function to return a subtype of <code class="highlighter-rouge">B</code>. The Liskov substitution principle enables principled reasoning about subtyping.</p>

<p><strong>Local Reasoning</strong>. <em>Local reasoning</em> is a property of some code wherein the correctness of the code can be inferred locally under specified assumptions, without considering prior application state or all possible inputs.</p>

<p><strong>Map</strong>. To <em>map</em> over a polymorphic data type is to change one type parameter into another type, by specifying a way to transform values of that type. For example, a list of integers can be mapped into a list of strings, by specifying a way to transform an integer into a string. To be well-defined, and to constitute a valid <code class="highlighter-rouge">Functor</code>, mapping over any polymorphic data type with an identity function must yield something that is equal to the original value.</p>

<p><strong>Minimal</strong>. A set of operators is <em>minimal</em> if there exist no smaller set of orthogonal operators that has the same expressive power.</p>

<p><strong>Modular</strong>. A factoring of a solution to a problem is <em>modular</em> when it has been divided into independent concerns called <em>modules</em>, such that each module knows no more than necessary about other modules. Modularity helps tame the complexity of large-scale software development.</p>

<p><strong>Monad</strong>. A <code class="highlighter-rouge">Monad</code> is an <code class="highlighter-rouge">Applicative</code> Functor that allows combining a first <em>functional effect</em>, together with a function that takes the success value of the first effect and returns a second effect (<em>continuation</em>). Monads represent the essence of imperative programming: do a first thing, and then do this second thing, which depends on the value computed by the first thing. Under the view of functors as DSLs, <code class="highlighter-rouge">Monad</code> adds sequential ‚Äústatements‚Äù, where subsequent statements depend on previous ones.</p>

<p><strong>Monad Transformer</strong>. A <em>monad transformer</em> is a data type that adds one functional effect atop any other functional effect. For example, the <code class="highlighter-rouge">OptionT</code> (<code class="highlighter-rouge">MaybeT</code>) monad transformer adds the effect of optionality to any other functional effect. A monad transformer, when ‚Äústacked‚Äù atop a monad, itself forms a monad, which allows building up large stacks of monad transformers, each layer adding some desired functional effect. Monad transformers have significant performance overhead in languages like Scala. An alternative to monad transformers is <em>effect rotation</em>.</p>

<p><strong>Monoid</strong>. A monoid is a semigroup equipped with a <em>neutral element</em> (often called <em>zero</em>), such that appending the neutral element to any other element (on either side) returns that same element unchanged.</p>

<p><strong>Monomorphic</strong>. <em>Monomorphic</em> is the opposite of <em>polymorphic</em>, and refers to a function that takes no type parameters (instead, all of its inputs are concrete types), or a data type that takes no type parameters (rather, it defined entirely with concrete types).</p>

<p><strong>Natural Transformation</strong>. A <em>natural transformation</em> is any polymorphic function between <em>Functors</em>.</p>

<p><strong>Nominal Typing</strong>. <em>Nominal typing</em> is a method of defining types solely based on their names. Two nominal types are equal if and only if they have the same fully-qualified name. Nominal typing stands in contrast to <em>structural typing</em>, in which two types that have different names but the same structure are regarded as the same.</p>

<p><strong>Onion Architecture</strong>. <em>Onion architecture</em> is a method of architecting programs that involves gradually translating business logic into lower-layer levels, until at the edges of the application, logic is translated into system calls. Applications written in the onion architecture bear similarities with multi-staged compilers, where every layer of the onion contains DSLs that are ‚Äúcompiled‚Äù into other DSLs.</p>

<p><strong>Optics</strong>. <em>Optics</em> are <em>values</em> that allow getting and setting smaller parts of a larger data structure, in a purely functional way. In the functional context, <em>setting</em> means to produce a new copy from an old copy, with some modification applied. Optics allow zooming into small parts of very large structures, and making pinpoint modifications, without having to deal with all the boilerplate involved in deconstructing and reconstructing every level of the data structure.</p>

<p><strong>Orthogonal</strong>. Roughly speaking, a set of operators is <em>orthogonal</em> when no operator performs the function of any other operator. This is the functional programming analogue of <em>Single Responsibility Principle</em> (SRP). More precisely, a set of operators <code class="highlighter-rouge">S</code> is <em>orthogonal</em> if there exists no other factoring of the operators <code class="highlighter-rouge">S1</code> such that any operator in <code class="highlighter-rouge">S</code> can be expressed as a composition of two or more operators in <code class="highlighter-rouge">S1</code>.</p>

<p><strong>Parametric Polymorphism</strong>. Sometimes called <em>generics</em>, <em>parametric polymorphism</em> is a feature of some programming languages that allows <em>universally quantifying</em> a function or a data type over one or more type parameters. Such <em>polymorphic functions</em> and <em>polymorphic data types</em> are said to be <em>parameterized</em> by their type parameters. Parametric polymorphism allows the creation of generic code, which works across many different data types, and generic data types, like collections. Parametrically polymorphic code must behave uniformly across all choice of type parameters, which allows a powerful way of reasoning about such code called <em>parametric reasoning</em>.</p>

<p><strong>Parametric Reasoning</strong>. <em>Parametric reasoning</em> is a type of reasoning that enables one to state facts about an implementation of a polymorphic function or polymorphic data type based only on type signatures. Parametric reasoning is typically accomplished using <em>flow analysis</em> on polymorphic declarations.</p>

<p><strong>Partial Function</strong>. A <em>partial function</em> is a function that is only defined for a subset of its domain. Partial functions can be modeled as total functions by expanding the codomain to include at least one new value, which indicates the function does not handle some input.</p>

<p><strong>Polymorphism</strong>. <em>Polymorphism</em> is a feature of programming languages that allows a variable or function to take on many different forms. Common types of polymorphism include <em>parametric polymorphism</em>, <em>subtype polymorphism</em>, and <em>ad hoc polymorphism</em>.</p>

<p><strong>Prisms</strong>. <em>Prisms</em> are <em>optics</em> that allow getting and setting terms in <em>sum types</em>. For example, a prism could allow getting and setting the <code class="highlighter-rouge">Left</code> term inside objects of type <code class="highlighter-rouge">Either[A, B]</code> (<code class="highlighter-rouge">Either a b</code>). In the functional context, <em>setting</em> a term in a sum means creating a new sum, given the new value for the term.</p>

<p><strong>Procedures</strong>. In programming languages, <em>procedures</em> are named entities that contain ordered sets of instructions for a machine to perform. Usually called <em>functions</em>, <em>procedures</em>, or <em>subroutines</em> in common parlance, procedures are not necessarily <em>functions</em> in the mathematical sense of the word, although all mathematical functions on values constitute valid procedures.</p>

<p><strong>Procedural Programming</strong>. <em>Procedural programming</em> is a style of programming in which solutions are constructed from the construction and invocation of procedures. All procedural programming is <em>imperative</em> in nature, although not all imperative programming is <em>procedural</em>.</p>

<p><strong>Product Type</strong>. A <em>product type</em> is the composition of <code class="highlighter-rouge">n</code> types, referred to as the <em>terms</em> of the product, together into a new type, such that a value of the product type contains a value from each of its terms. Structs, classes, records, and tuples are all examples of product types. A table is also an example of a product type, because each row in a table contains a value from each of its columns.</p>

<p><strong>Profunctor</strong>. A <em>profunctor</em> is type class defined over type constructors of two type parameters that describes polymorphic data types that form a <code class="highlighter-rouge">Functor</code> in one type parameter, and a <code class="highlighter-rouge">Contravariant</code> Functor in the other type parameter. Functions are examples of profunctors, which can be mapped on the output channel, and contramapped on the input channel. Profunctors can be thought of as a generalization of functions, which accept input and produce output, but most profunctors are not functions.</p>

<p><strong>Projection</strong>. A <em>projection</em> is a ‚Äúlossy‚Äù mapping from one set to another set, such that if applied again to the output of itself, returns an equivalent result. An example is pulling the <em>age</em> field out of a <em>Person</em>, in which case repeated application produces the same <em>age</em> field. All extractions of terms from product types can be regarded as projections.</p>

<p><strong>Property-based Testing</strong>. <em>Property-based testing</em> is a method of testing <em>algebraic laws</em> by pseudo-randomly generating example values, and testing to see if the laws are satisfied. For example, property-testing could generate many integers <code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">b</code>, and <code class="highlighter-rouge">c</code> to check if <code class="highlighter-rouge">(a + b) + c</code> is equal to <code class="highlighter-rouge">a + (b + c)</code>. Property-based testing cannot <em>prove</em> laws, but it can disprove them, as well as ensure there are no trivial law violations.</p>

<p><strong>Pure</strong>. A <em>pure</em> procedure combines inputs into an output, and does not interact with the world outside the function in any way that can be observed. All pure procedures are <em>deterministic</em>, but not all <em>deterministic</em> procedures are pure.</p>

<p><strong>Record</strong>. A <em>record</em> contains <code class="highlighter-rouge">n</code> fields, each accessed with some <em>label</em>, called the <em>name</em> of the field, and each with some associated type. All records are product types, although not all product types are records (for example, terms of tuples are accessed by ordinal values, not names).</p>

<p><strong>Recursive Data</strong>. <em>Recursive data</em> is any data type that appears as a value somewhere inside the data type. Common examples of recursive data include linked-lists and trees.</p>

<p><strong>Recursive Functions</strong>. <em>Recursive functions</em> are functions that call themselves. In functional programming, recursive functions allow iteration, like processing elements in a list or accepting socket connections.</p>

<p><strong>Recursion Schemes</strong>. <em>Recursions schemes</em> refers to any of the many different ways to traverse recursive data types, such as folding (catamorphisms) or unfolding (anamorphisms). Typically <em>recursion schemes</em> refers to the use of fixed-point data types to factor out recursion from data types, and minimize the boilerplate involved in creating different recursion schemes for different recursive data types. However, fundamentally, any recursive data type can be constructed, deconstructed, and transformed in any of the different schemes.</p>

<p><strong>Referential Transparency</strong>. <em>Referential transparency</em> is a property of functional programs in which any expression may be replaced by the value it computes without changing the behavior of the program. Referential transparency allows refactoring programs without changing their behavior, and is necessary (but not sufficient) for <em>local reasoning</em>.</p>

<p><strong>Reified</strong>. A <em>reified</em> construct is some non-value construct (such as a type, a field, or a package) that has been represented as a value. For example, reified generics store the type of generic type parameters as values at runtime. Similarly, lenses are a type of reified field, which provide a way to treat a field of a record as a first-class value, which can be passed around, stored, and transformed.</p>

<p><strong>Semigroup</strong>. A <em>semigroup</em> is a type class with a single binary operator, often called <em>append</em> or <em>combine</em>, that is <em>assocative</em>.</p>

<p><strong>Side-Effect</strong>. A <em>side-effect</em> occurs when evaluation of an expression does anything more than computing a value. Side-effects are interactions that can be observed from outside a procedure or expression. Common side-effects include database access, file access, network access, system calls, modifying mutable memory, or calling procedures that do any of the above.</p>

<p><strong>State</strong>. <em>State</em> refers to any data that is used to iteratively process information, either in a loop, or using recursion.</p>

<p><strong>Structural Typing</strong>. <em>Structural typing</em> is a method of defining types solely based on their structure. Two structural types are equal if and only if they have the same structure. Structural typing stands in contrast to <em>nominal typing</em>, in which two types that have the same structure are regarded as different if they have different names.</p>

<p><strong>Structure</strong>. The <em>structure</em> of a data type is the set of statements we know to be true about the data type. Parametrically polymorphic types (as well as <code class="highlighter-rouge">Any</code> in Scala) have <em>no</em> structure, but we can add structure by requiring these types have <em>instances</em> for one or more <em>type classes</em>.</p>

<p><strong>Subtyping</strong>. <em>Subtyping</em> is a method of defining types that permits ‚Äúsubset‚Äù relations, where one type is defined to be a subset or superset of another type. For example, all dogs are animals, and a type system with subtyping can recognize the fact that a <code class="highlighter-rouge">Dog</code> type is a subset of an <code class="highlighter-rouge">Animal</code> type.</p>

<p><strong>Sum Type</strong>. A <em>sum type</em> is the composition of <code class="highlighter-rouge">n</code> types together in an enumeration type, where each case of the enumeration is referred to as a <em>term</em> in the sum type. A value from a sum type contains a value from exactly one of its terms. For example, a value of a <code class="highlighter-rouge">Suite</code> enumeration is either <code class="highlighter-rouge">Hearts</code>, <code class="highlighter-rouge">Diamonds</code>, <code class="highlighter-rouge">Spades</code>, or <code class="highlighter-rouge">Clubs</code>. In Scala 2.x, enumerations are emulated with <code class="highlighter-rouge">sealed trait</code>, where the terms of the sum type are subtypes of the <code class="highlighter-rouge">sealed trait</code>.</p>

<p><strong>Tagless-Final</strong>. <em>Tagless-final</em> refers to a way of encoding the interpretation of a DSL using parametric polymorphism. In tagless-final, code written in a DSL is polymorphic in the data type used for interpretation. This polymorphic code is interpreted in different ways by instantiating it to concrete evaluation types. In Scala, <em>tagless-final</em> refers almost exclusively to using <em>indirection</em> to provide ad hoc operations across polymorphic effect types.</p>

<p><strong>Total</strong>. A <em>total</em> procedure returns an output for every input. Total procedures, unlike partial procedures, always terminate, and they never throw exceptions.</p>

<p><strong>Traversals</strong>. <em>Traversals</em> are <em>optics</em> that allow getting and setting elements in collection-like data structures.</p>

<p><strong>Type</strong>. A <em>type</em> is information that exists at compile-time, stored in the computer‚Äôs memory as the program is compiling. Types are used by the compiler to describe the structure of variables and functions, to ensure programs are well-defined and consistent. Informally, a type can be regarded as a mathematical set of values; the type <code class="highlighter-rouge">Boolean</code>, for example, contains the values <em>true</em> and <em>false</em>. To ascribe a variable a type in a programming language is to assert the value is a member of the set described by the type, and the act of constructing such a value can be regarded as a proof that the assertion is correct.</p>

<p><strong>Type Class</strong>. A <em>type class</em> is a language-level encoding of an <em>abstraction</em>. Type classes can be viewed as functions from some type to an <em>algebraic structure</em> for that type. For example, an <code class="highlighter-rouge">Ord</code> type class might encode the algebraic structure of total ordering, and might allow us to access ordering operations for types that have this algebraic structure.</p>

<p><strong>Type Constructors</strong>. A <em>type constructor</em> is a type that is itself parameterized by other types. To construct a type, the type constructor must be <em>fully applied</em> to all of its parameters, which then results in a type. For example, <code class="highlighter-rouge">List</code> (<code class="highlighter-rouge">[]</code>) is a type constructor. Given a type, such as <code class="highlighter-rouge">Int</code> (<code class="highlighter-rouge">Integer</code>), then ‚Äúpassing‚Äù that type to the <code class="highlighter-rouge">List</code> type constructor then constructs a type: namely, the type of lists with that specified element type. The structure of a type constructor is described by its <em>kind</em>.</p>

<p><strong>Universal Quantification</strong>. <em>Universal quantification</em> asserts that a statement holds for all possible choices of a given variable. All <em>parametrically polymorphic</em> functions and data types universally quantify over their type parameters, asserting the function or data type has an implementation for all possible choices of the type parameters. For example, the function <code class="highlighter-rouge">def empty[A]: List[A]</code> (<code class="highlighter-rouge">empty :: [a]</code>) universally quantifies over the type parameter <code class="highlighter-rouge">A</code>, asserting that for any element type, the function can produce a list of that element type (namely, the empty list).</p>

<p><strong>Universal Type</strong>. A <em>universal type</em> is any type variable used in <em>univeral quantification</em>. In programming languages, universal types are introduced by <em>parametrically polymorphic</em> function and data type declarations.</p>

<p><strong>Value</strong>. A <em>value</em> is information that exists at runtime, stored in the computer‚Äôs memory as the program is executing. Values are used to hold and transmit information within a program, and across process boundaries, to the operating system, file system, network, and beyond. In programming languages, values are constructed from literals or from <em>expressions</em>.</p>

<h2 id="faq">FAQ</h2>

<p><em>Question</em>: Can you define some other term that I find confusing?</p>

<p><em>Answer</em>: Sure, send it on and I‚Äôll add it to the glossary!</p>

<p><em>Question</em>: Wikipedia doesn‚Äôt agree with your definitions.</p>

<p><em>Answer</em>: Oh no!</p>

<p><em>Question</em>: I don‚Äôt agree with your definitions.</p>

<p><em>Answer</em>: Ok.</p>

<p><em>Question</em>: Change your definitions to what I want!</p>

<p><em>Answer</em>: Nope. But if you have ideas to improve these definitions, please share your feedback!</p>
:ET